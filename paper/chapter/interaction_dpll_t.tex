\subsection{Integration  into SMT solver architecture}
\label{sec:Implementation in DPLLt}
In this section we will explain, how the string theory solver is integrated into modern DPLL($T$) framework.
We will briefly discuss the issues of $theory\ propagation$, $lemma\ learning$ and $conflict\ analysis$.

 
Modern SMT solvers combine a SAT solver with multiple specialized $theory\ solvers$. The SAT solver maintain an evolving set $F$ of clauses and a set $M$ of literals representing partial assignment. The whole process is derived by the SAT solver. It periodically consults the theory solver, to find whether $M$ is satisfiable in its theory. The literals of an assignment $M$ are partitioned into string constraints, arithmetic constraints. These sets are subsequently given to the independent solvers. The rules \texttt{A-Prop} and \texttt{S-Prop} model the mechanism for $theory\ combination$. This mechanism is known as Nelson-Oppen theory combination \cite{nelson_oppen}, where the entailed equalities are communicated between multiple solvers. The rule \texttt{A-Conflict} modeled the satisfiability checking done by the arithmetic solver. As there is no additional requirement for the arithmetic solver, a standard theory solver for linear integer arithmetic can be used. 

The case splitting done by the string solver (with rules \texttt{S-Split} and \texttt{L-Split}) is achieved by means of the $splitting\ on\ demand$ paradigm, in which a solver may add theory lemmas to $F$ consisting of clauses possibly with literals not occurring in $M$.  This approach of $lemma\ learning$ is very efficient as new lemmas are introduced only when it is needed.  Similarly, the rules \texttt{Len}, \texttt{Len-Split}, and \texttt{Card} are involved in introduction of new constraints into \texttt{A}. This is done by the string solver by adding lemmas to ${F}$ containing arithmetic constraints. For example, if $x \approx \texttt{con}(y, z) \in \mathcal{C}(\texttt{S})$, the solver may add a lemma of the form $ \psi \Rightarrow \texttt{len}\ x \approx \texttt{len}\ y + \texttt{len}\ z$ to $F$, where $\psi$ is a conjunction of literals from $M$ entailing $x \approx \texttt{con}(y, z)$, after which the conclusion of this lemma is added to $M$.

When a theory solver determines that $M$ is unsatisfiable, it produces a $conflict\ clause$ to support the decision. A $conflict\ clause$ is the negation of an unsatisfiable subset of $M$. Whenever the string solver introduces any equality to \texttt{S}, it also maintains an explanation $ \psi_{s,t}$ for each equality $s \approx t$. An explanation $\psi_{s,t}$ is a conjunction of string constraints in $M$ such that $\psi_{s,t} \models s \approx t$. When a configuration is decided to be unsatisfiable by rule \texttt{S-Conflict},that is, when $ s \approx t, s \not\approx t \in \mathcal{C}(\texttt{S})$ for some $s, t,$ it replaces the occurrence of $s \approx t$ with its corresponding explanation $\psi$, and then replaces the equalities in $\psi$ with their corresponding explanation, and so on, until $\psi$ contains only equalities from $M$. Finally, it reports the conflict clause 
$ \psi \Rightarrow s \approx t$.

The core idea of the above explanations are taken from \cite{main-paper}.